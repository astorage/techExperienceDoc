事情描述的关键
STAR(situation, task, action, results)

消息中间件：kafka，rabbitMQ，RocketMQ

用处：
1、应用解耦
2、异步消息  要设计异步业务上镜
3、流量削锋  先响应前台，后台需要处理的数据先放到MQ中


事务隔离级别

1、读未提交——read uncommitted  存在脏读问题
   一个事务能看到其他事务未committed的数据

2、读已提交——read committed  问题：不可重复读
   一个事务只能看到其他事务已committed的数据

3、可重复读——repeateble read 存在幻读问题 可insert不可update
   读取的数据不可更改。 读取的时候不可以写  行锁  
   
4、序列化——serializable 事务串行化执行


锁

普通的select …… from where ……不加锁，读取数据快照，如果事务开始之后更新的数据，读取的事务是不会看到的。

特殊的读 select …… for update， or lock in share mode


锁策略：
	表级锁；不会走索引
	行级锁：锁住满足条件的数据，可以用索引

锁种类：
	共享锁：读锁，其他的事务可读不可修改。
	排它锁：写锁，其他事务不可读也不可修改。
	
	
类加载过程
	
	加载——》连接(验证——》准备——》解析)——》初始化——》使用——》卸载
	
一、加载classloader
1、通过全限定名获取 定义类的二进制字节流
2、将二进制字节流——》生成内存中方法区的运行时数据结构
3、在内存中生成class对象，作为访问入口

注：连接和加载可以交叉进行，这两阶段的开始时间先后顺序是固定的。


二、验证——保证加载的字节流符合虚拟机的要求，不会危害虚拟机。
1、文件格式验证，是否符合class文件格式规范。
2、元数据验证，语义分析，保证没有语法错误。
3、字节码验证
4、符号引用验证

注：验证阶段重要但不是必须的。可设置-xverifynone 参数关闭类的验证

三、准备

正式为类（static）变量分配内存（栈内存），并设置默认值，类变量的内存都分配在方法区中（栈中）

解析：
1、实例变量分配在堆中，在对象实例化时分配
2、类变量是在初始化阶段才会执行
3、final static变量是在 准备阶段赋值的。

四、解析

将常量池中的符号引用替换为直接引用。类，接口，字段，类方法，接口方法，方法类型，方法句柄，调用点限定符


五、初始化 
  开始真正执行类定义中的java程序
  
  <clinit>()   静态变量赋值动作
			 静态语句块中的语句  构成
			 
	
在静态语句块中，可以给定义在后面的静态变量赋值。但是不能访问定义在后面的静态变量。


如果类中没有定义静态变量和静态语句块，就没有<clinit>()

虚拟机会保证<clinit>()只有一个线程执行，且只会执行一次

同一个类加载器下，一个类只会被初始化一次。


1、类数组定义，不会触发此类初始化
Student[] student = new Student[10];

2、常量在编译阶段会存入调用类的常量池。使用常量本质上并没有引用定义常量的类，因此不会触发定义常量的类初始化。
System.out.println(Constant.HELLO_WORLD);


对象构造方法：init() 
1、先初始化成员变量
2、非静态语句块
3、构造方法

类构造方法：<clinit>()
1、静态变量 
2、静态语句块 

实例初始化不一定在类初始化结束之后。


=============================

sql优化
1、速度太慢，先建索引
2、使用参数化sql（主要是预编译，查询优化，还可避免sql注入）
3、where子句中的条件，内过滤更多的数据放在前面
4、能放在一起关联查询的，就不要法分开查询，可以减少玩过连接，权限校验，sql优化，发送执行结果（现在提倡单表查询）
5、查询条件不要放在having子句中，having主要过滤聚合函数。
6、使用表的别名，可减少解析时间
7、in和exist都可用时，用exist，因为用in不用索引
8、不要在索引字段上计算
	salary * 12 > 2500 效率低
	salary > 2500 / 12 效率高
9、用union all 替换 union，在不会有重复记录的情况。 （union会排序去重，不过很少用union）

10、不用索引的情况
	is not null  （定义字段时，一定设置默认值，而不是defualt null）
	不等于判断 != <>
	like "%c" "a%c"  %在前面或加载中间

sql优化，都是针对大数据量的情况，数据量小，怎么都没问题

1、避免全表扫描，首先考虑在where及order by涉及的列上建立索引

2、避免在where子句中对字段进行null判断（is null 或者 is not null），null判断会导致不使用索引。

3、避免在where子句中使用不等号操作（!= 或者 <>），因为会导致不使用索引

4、or连接的条件，如果有一个没走索引，将导致放弃索引

   select id from where num = 10 or name = 'admin' 
   改为：
   select id from where num = 10
   union all
   select id from where name = 'admin' 
   
5、能用between and， exist，就不用 in， not in

6、如果子句使用参数，会导致全表扫描（索引查询应该是已知值，不能是位置参数）

8、不要在条件字段上使用函数，进行算数运算 或者 表达式运算

9、符合索引，遵循前缀匹配。

10、update语句，如果值修改部分字段，不要update全部字段。频繁调用会引起明显的性能消耗，同时带来大量日志。

11、一个表不要建立太多索引， select效率增高，update，insert效率会降低，以为可能会引起重建索引

12、clustered索引，不要更新，因为clustered索引数据列的顺序是记录的物理顺序，改了值会导致表记录的调整。

13、字段能用数值类型就不要字符类型，因为数值容易比较

14、varchar比char好些

15、不要返回用不到的字段，不要用*，要列出查询的字段。

16、临时表可用select into 代替 create table 避免造成大量log以提高速度。

17、数据类型转换不能使用索引





硬件的速度快慢

cpu 》 cache 》 内存 》SSD硬盘 》网络 》硬盘

硬件的使用场景

cpu、cache、内存：缓存数据访问、比较、排序，事务检测，sql解析，算术运算，逻辑运算

网络：结果数据传输，sql请求，远程数据访问

硬盘：数据访问，数据写入，日志记录，大量数据排序(硬盘排序，或者外排)，大表连接。


优化规则：
1、减少数据访问（减少磁盘访问）
2、返回更少数据（减少网络传输、磁盘访问）
3、减少交互次数（减少网络传输）
4、减少cpu开销
5、利用更多资源（增加资源）



使用变量绑定，预编译 （好）

select * from employee where id = ?
PreparedStatement.setInt(4234)

不使用变量绑定

select * from employee where id = 4234


复合索引，前导匹配


sql执行计划  

查看desc explain结果

聚集索引 ：表述的是一种数据存储方式，索引信息和数据信息存放在一起。 mysql-innodb的主键（或者默认主键）就是使用的这种方式
非聚簇索引： 索引信息和数据信息分开存放。

mysql使用索引查询数据的过程
1、先通过我们自己定义的索引找到数据对应的主键   非聚集索引
2、然后通过主键获取数据							聚集索引

mysql-innodb 主键就是聚集索引，b+树叶子节点存放的是数据。
mysql-myisam 非聚集索引，b+树叶子节点中存放的是数据地址。


mysql引擎种类

mysql索引底层逻辑  B+tree

主要是innodb
myisam 
memory



6大设计原则

1、开闭原则————能增加不能修改
2、单一职责原则————子类不能重写父类的方法，可以增加方法。
3、接口隔离原则————使用接口编程
4、依赖倒置原则————接口方法要少，多写几个接口没事的。
5、理氏替换原则
6、迪米特法则————访问控制权限尽量缩小。


23设计模式

5创建型

单例模式
原型模式
工厂方法模式
抽象工厂模式
建造者模式

7结构型

适配器模式
代理模式
装饰模式
桥接模式
外观模式
组合模式
享元模式

11行为型

模板方法模式
责任链模式
状态模式
命令模式
策略模式
访问者模式
观察者模式
解释器模式
迭代器模式
备忘录模式
中介者模式


======================================

判断对象是否可被回收
1、引用计数法（被引用+1，取消引用-1，计数器为0时可被回收）存在循环引用的问题
2、根搜索算法:思想是通过一系列“GC Roots”对象作为起点，从这些节点往下搜索，搜索走过的路径称为引用链，
              当一个对象到“GC Roots”对象没有任何引用链时，表示对象不可用。
			  
	java中可以作为GC-roots的有一下几类：
	1、虚拟机栈中引用的对象
	2、方法区中静态属性引用的对象
	3、方法区中常量引用的对象
	4、本地方法栈中native方法引用的对象


垃圾回收算法：
1、标记清除算法    问题：内存碎片，没有大对象可用内存
2、复制清除算法    问题：浪费内存。内存分两块，大小相等，使用其中一块，用完，将存活对象copy到另一块，清空第一块。
3、标记整理算法    标记垃圾对象，然后将存活对象移动到内存一端，清理另一端。
4、分代收集算法	   根据java对象生命周期特点将内存区域或分为大小不等的若干个区域。不同的区域采用不同的具体垃圾收集算法
				   新生代（survivor：survivor：eden）：old = （1:1:8）1:2
				   新生代采用复制清除算法——新生代的对象生命周期都很短，大部分对象都可以回收。
				   老年代采用标记整理算法——老年代的对象生命周期都很长，每次一小部分对象可以回收。
				   
minor gc 新生代   频率高，资源消耗少
full gc 整个堆内存（老年代，新生代）   频率低，资源消耗多


内存一些配置参数 
-xms jvm初始值大小
-xmx jvm最大值
-xmn 年轻代大小
-xss 线程的大小


===========================================
并发相关

volatile  保证变量可见性。当一个线程修改了共享变量，另一个线程能读取到新的值。

cpu缓存  数据总线   内存

cpu1      cpu2        cpu3         cpu4
cache1    cache2      cache3       cache4

--------------------------------------------  总线

============================================  内存 

没有volatile的变量，不确定什么时候将缓存中的数据写入内存


1、可见性
2、禁止指令重排——有序性




参考文档：
https://www.cnblogs.com/dolphin0520/p/3920373.html


happens-before



OSI七层模型

应用层		

表示层

会话层

传输层

网络层

数据链路层

物理层


OSI五层模型

应用层	

传输层

网络层

数据链路层

物理层























































































































































































